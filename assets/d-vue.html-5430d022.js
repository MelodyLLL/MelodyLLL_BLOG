import{_ as e,o as a,c as n,a as s}from"./app-abb8a49b.js";const t={},i=s(`<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1><h2 id="mvvm-是什么" tabindex="-1"><a class="header-anchor" href="#mvvm-是什么" aria-hidden="true">#</a> MVVM 是什么</h2><p>MVVM 是 Model-View-ViewModel 缩写，Model 代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 的桥梁，数据会绑定到 ViewModel 层并自动将数据渲染到页面中，视图变化时会通知 ViewModel 层更新数据。</p><h2 id="vue-的双向绑定原理" tabindex="-1"><a class="header-anchor" href="#vue-的双向绑定原理" aria-hidden="true">#</a> vue 的双向绑定原理</h2><ol><li>初始化 data，做两件事情，一把 vm.data.xxx 代理到 vm.xxx，二调用 observe 方法观测整个 data，给非 VNode 的对象类型数据添加一个 Observer</li><li>Observer： 会把自身实例添加到对象的 <code>__ob__</code> 属性上，遍历对象类型数据通过 <code>Object.defineProperty</code> 添加 getter 和 setter</li><li>Dep：属于 Observer 的一个属性，用于收集依赖，在 getter 中把每一个调用过该属性的地方记录为依赖（即触发 getter 的地方进行收集并且让 watcher 订阅对应依赖），在 render 方法执行的时候完成对应 watcher 的订阅</li><li>Watcher：Dep 下的一个 subs 数组，它的类型为 Watcher，更改数据后触发 setter，让所有 wathcer 都去通知组件进行更新</li><li>补充特征： <blockquote><ol><li><p><strong>Proxy 的使用</strong>：Vue 3 引入了 Proxy 对象作为响应式系统的一部分。与 Object.defineProperty 不同，Proxy 允许对整个对象进行代理，而不仅限于属性。这使得 Vue 能够更加灵活地监听对象的变化，并且 Proxy 也能够提供更多的拦截器（如 <code>get</code>、<code>set</code>、<code>has</code> 等），使得对对象的操作更加直观和易于理解.</p></li><li><p><strong>数据变更的批处理</strong>：Vue 中的响应式系统会将所有数据变更操作放入一个队列中，并在下一个事件循环中进行批处理。这种机制可以减少 DOM 更新次数，提高性能。通过批处理，Vue 可以将多次数据变更合并成一次更新，避免了不必要的重复计算和渲染，从而提高了页面的响应速度和性能.</p></li><li><p><strong>依赖收集的细节</strong>：Vue 在进行依赖收集时，不仅在 getter 中收集依赖，还会进行静态依赖的分析。这意味着 Vue 在模板编译阶段会分析模板中的数据依赖关系，并将这些依赖关系静态地收集起来，以提高依赖收集的效率和性能。此外，Vue 在数据变更时会进行异步的依赖通知，以保证依赖更新的顺序和性能，避免不必要的重复渲染.</p></li><li><p><strong>Watcher 的分类</strong>：Vue 中的 Watcher 不仅用于视图更新，还有计算属性的 Watcher 和监听器的 Watcher。计算属性的 Watcher 用于监听计算属性的变化，并且只有在其依赖的数据发生变化时才会重新计算；监听器的 Watcher 用于监听数据的变化，并在数据变化时执行相应的回调函数。这些 Watcher 之间有着不同的作用和触发时机，使得 Vue 的响应式系统更加灵活和高效.</p></li><li><p><strong>对数组的双向绑定略有不同</strong>：使用了函数劫持的方式，重写了数组的方法，将 data 中的数组进行了原型链重写，指向自己定义的数组原型方法，这样当调用这些数组 api 时，可以通知依赖更新，如果数组中包含着引用类型，会对数组中的引用类 再次递归遍历进行监控，这样就能监测到数组的变化了。</p></li></ol></blockquote></li></ol><h2 id="vue-组件通讯" tabindex="-1"><a class="header-anchor" href="#vue-组件通讯" aria-hidden="true">#</a> vue 组件通讯</h2><ul><li>props+events 父子组件通信（parent/parent/parent/children）</li><li>vuex 任何组件通信</li><li>事件中心 emit/emit / emit/on 任何组件的通信</li><li>attrs/listeners 传递属性和事件</li><li>跨层级通信（provide / inject）</li></ul><h2 id="computed-和-watch-的区别和使用场景" tabindex="-1"><a class="header-anchor" href="#computed-和-watch-的区别和使用场景" aria-hidden="true">#</a> computed 和 watch 的区别和使用场景</h2><ul><li>计算属性当依赖的属性发生变化时就会更新视图，适用于比较消耗性能的场景。具有缓存性。</li><li>watch 不会缓存，每当监听的数据发生变化时都会执行，可以监听某些数据执行回调。</li></ul><h2 id="nexttick-api-的原理" tabindex="-1"><a class="header-anchor" href="#nexttick-api-的原理" aria-hidden="true">#</a> nextTick api 的原理</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。原理是根据执行环境分别尝试使用 Promise，MutationObserver，setImmediate，setTimeout。</p><h2 id="vuex-有哪些属性" tabindex="-1"><a class="header-anchor" href="#vuex-有哪些属性" aria-hidden="true">#</a> vuex 有哪些属性</h2><p>有五种，分别是</p><ul><li>state（存储变量）</li><li>mutation（提交更新数据的方法，修改 vuex 中状态的唯一方法）</li><li>action（提交 mutation，可以包含任意异步操作）</li><li>getter</li><li>module（模块化 vuex）</li></ul><h2 id="set-方法是什么" tabindex="-1"><a class="header-anchor" href="#set-方法是什么" aria-hidden="true">#</a> $set 方法是什么</h2><p>$set方法相当于手动的去把set进去的属性处理成一个响应式的属性。this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)</p><h2 id="name-的作用" tabindex="-1"><a class="header-anchor" href="#name-的作用" aria-hidden="true">#</a> name 的作用？</h2><p>1.注册组件使用组件名.name 2.keep-alive exclude=‘name’ 3.使用 vue-tool 工具时显示的是 name</p><h2 id="vue-生命周期简述" tabindex="-1"><a class="header-anchor" href="#vue-生命周期简述" aria-hidden="true">#</a> vue 生命周期简述</h2><ul><li>beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data，computed，methods 以及 watch 上的数据和方法都不能被触发。</li><li>created 在实例创建完成后发生，这个阶段可以使用数据，更改数据，但不会触发 update 函数，无法与 Dom 进行交互。</li><li>mounted 在挂载完成后发生，数据完成双向绑定，可以访问到 Dom 节点，使用$ref 属性对 Dom 进行操作。</li><li>beforeUpdate 发生在更新之前，响应式数据发生更新，虚拟 Dom 被渲染之前</li><li>updated 发生在更新完成之后，Dom 更新完成</li><li>beforeDestroy 发生在实例销毁之前，可以清除定时器。</li><li>destroyed 发生在实例销毁之后，这个时候 Dom 是空的，组件被拆解，数据绑定被卸除，监听被移除，子实也 都销毁。</li></ul><h2 id="proxy-只会代理对象的第一层-vue3-是怎么解决这个问题" tabindex="-1"><a class="header-anchor" href="#proxy-只会代理对象的第一层-vue3-是怎么解决这个问题" aria-hidden="true">#</a> proxy 只会代理对象的第一层，vue3 是怎么解决这个问题？</h2><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理，这样就实现深度观测。</p><h2 id="v-if-和-v-show-的区别" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show-的区别" aria-hidden="true">#</a> v-if 和 v-show 的区别？</h2><p>当条件不成立时，v-if 不会渲染 Dom 元素，v-show 操作的样式，通过 display 来切换当前 DOM 的显示和隐藏。</p><h2 id="data-为什么是个函数" tabindex="-1"><a class="header-anchor" href="#data-为什么是个函数" aria-hidden="true">#</a> data 为什么是个函数？</h2><p>为了保证组件不同的实例之间不冲突。一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数，如果 data 是一个对象的话，对象属于引用类型，会影响到所有的实例。</p><h2 id="vue-事件绑定的原理" tabindex="-1"><a class="header-anchor" href="#vue-事件绑定的原理" aria-hidden="true">#</a> vue 事件绑定的原理？</h2><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过$on 实现的。</p><h2 id="hash-路由和-history-的实现原理" tabindex="-1"><a class="header-anchor" href="#hash-路由和-history-的实现原理" aria-hidden="true">#</a> hash 路由和 history 的实现原理</h2><p>location.hash 的值实际就是 URL#后面的东西 history 实际采用了 HTML5 中的提供的 API 来实现，主要有 history.pushState()和 history.replaceState().</p><h2 id="vue2-x-和-vue3-x-渲染器的-diff-算法" tabindex="-1"><a class="header-anchor" href="#vue2-x-和-vue3-x-渲染器的-diff-算法" aria-hidden="true">#</a> vue2.x 和 vue3.x 渲染器的 diff 算法:</h2><p>diff 算法就是进行虚拟节点对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后用 patch 记录的消息去局部更新 Dom。 diff 算法有以下过程： 先同级比较，再比较子节点。 先判断一方有子节点一方没有子节点的情况，这样就给新的节点移除或者新增上子节点。 比较都有子节点的情况，递归的比较子节点。 vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 找到可以复用的节点，在进行相关操作。 vue3 在创建 VNode 的时候就确定其类型，在 patch 的过程中采用位运算来判断一个 VNode 的类型，再配合核心 diff 算法。</p><h2 id="keep-alive-使用和原理" tabindex="-1"><a class="header-anchor" href="#keep-alive-使用和原理" aria-hidden="true">#</a> keep-alive 使用和原理</h2><p>keep-alive 可以实现组件缓存，当组件切换时不会对组件进行卸载。 常用的两个属性 include/exclude，允许组件有条件的进行缓存。 两个生命周期 activated/deactivated，用来判断当前组件是否处于活跃状态。</p><h2 id="vue-中组件生命周期的调用顺序" tabindex="-1"><a class="header-anchor" href="#vue-中组件生命周期的调用顺序" aria-hidden="true">#</a> vue 中组件生命周期的调用顺序</h2><ul><li>调用顺序都是先父后子，渲染完成的顺序都是先子后父。组件的销毁操作是先父后子，销毁完成的顺序是先子后父</li><li>加载渲染过程：父 beforeCreated-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreated-&gt;子 created-&gt;子 beforeMounted-&gt;子 mounted-&gt;父 mounted</li><li>子组件更新过程: 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</li><li>销毁过程： 父 beforeDestroyed-&gt;子 beforeDestroyed-&gt;子 destroyed-&gt;父 destroyed</li></ul><h2 id="写过-vue-自定义指令吗" tabindex="-1"><a class="header-anchor" href="#写过-vue-自定义指令吗" aria-hidden="true">#</a> 写过 vue 自定义指令吗？</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// main.js文件中引入Vue并创建根实例之前添加如下代码</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 自定义指令名为myDirective，使用bind钩子函数来处理元素被绑定时的操作</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">&#39;myDirective&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// el表示当前绑定了该指令的DOM元素</span>
		<span class="token comment">// binding包含了指令相关信息，比如传入的参数等</span>
		<span class="token comment">// 这里可以对DOM元素进行初始化设置、事件监听等操作</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>

	<span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// DOM元素已经被插入到页面中后调用此钩子函数</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>

	<span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// 当指令所在的模板重新渲染时会触发update钩子函数</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
	<span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="vue-中的性能优化有哪些" tabindex="-1"><a class="header-anchor" href="#vue-中的性能优化有哪些" aria-hidden="true">#</a> vue 中的性能优化有哪些</h2><p>编码阶段：</p><ol><li>尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的依赖。</li><li>v-if 和 v-for 不能连用</li><li>如果需要使用 v-for 给每项元素绑定事件时使用事件代理。</li><li>SPA 页面采用 keep-alive</li><li>在更多的情况下，使用 v-if 代替 v-show</li><li>key 保证唯一</li><li>使用路由懒加载，异步组件</li><li>防抖，节流</li><li>第三方模块按需导入</li><li>图片懒加载</li><li>css 在前，js 在后，css 在前可以和 dom 树一起合成 render 树，js 在后不阻塞 dom 渲染</li><li>减少 http 请求</li></ol><p>打包优化：</p><ol><li>压缩代码</li><li>使用 cdn 加载第三方模块</li></ol>`,43),l=[i];function o(c,p){return a(),n("div",null,l)}const d=e(t,[["render",o],["__file","d-vue.html.vue"]]);export{d as default};
