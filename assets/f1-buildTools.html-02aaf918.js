import{_ as c,f as d,o as p,c as i,g as e,h as r,i as o,a}from"./app-abb8a49b.js";const n={},t=a('<h1 id="前端基建和构建工具" tabindex="-1"><a class="header-anchor" href="#前端基建和构建工具" aria-hidden="true">#</a> 前端基建和构建工具</h1><h2 id="amd-和-cmd" tabindex="-1"><a class="header-anchor" href="#amd-和-cmd" aria-hidden="true">#</a> AMD 和 CMD？</h2><p>这两者都是 JavaScript 模块化规范，但在模块定义和加载的时机上存在一些区别。</p><h2 id="webpack-常用配置" tabindex="-1"><a class="header-anchor" href="#webpack-常用配置" aria-hidden="true">#</a> webPack 常用配置</h2>',4),h={href:"https://www.webpackjs.com/configuration/",target:"_blank",rel:"noopener noreferrer"},s=a('<h2 id="webpack-构建流程-说完整一些。" tabindex="-1"><a class="header-anchor" href="#webpack-构建流程-说完整一些。" aria-hidden="true">#</a> webpack 构建流程？说完整一些。</h2><p>webpack 构建流程：</p><p>初始化： 读取配置文件，初始化参数，加载插件。</p><p>编译： 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。</p><p>加载模块： 从入口文件开始，递归地构建整个依赖关系图，每个文件都会被转换成抽象语法树（AST）。</p><p>寻找 loader： 在加载模块的过程中，遇到对应的文件类型时，webpack 会调用配置好的 loader 来对文件进行转换。</p><p>构建模块： 递归地分析模块的依赖关系，根据依赖关系组装成一个个模块。</p><p>生成代码： 根据组装好的模块，生成最终的代码块（chunk），一个 chunk 由多个模块组成。</p><p>输出文件： 将最终的代码块写入到文件系统。</p><h2 id="webpack-的热更新怎么做到的" tabindex="-1"><a class="header-anchor" href="#webpack-的热更新怎么做到的" aria-hidden="true">#</a> webpack 的热更新怎么做到的？</h2><p>webpack 的热更新：</p><p>Webpack 的热更新（Hot Module Replacement，HMR）是一种在应用运行过程中替换、添加或删除模块的能力。实现步骤如下：</p><p>在应用代码中添加 HMR 代码： 通过 webpack 提供的 API，在应用代码中嵌入对模块的监听和更新处理逻辑。</p><p>开启 webpack 的 HMR 功能： 在 webpack 配置文件中配置 hot: true，告诉 webpack 启用 HMR。</p><p>服务器支持： 在开发服务器上启用 HMR 支持，这可以通过 webpack-dev-server 来实现。</p><p>客户端支持： 在浏览器中通过 WebSocket 等技术与服务器建立连接，当模块发生变化时，服务器通过连接通知客户端更新。</p><h2 id="webpack-中自定义-loader" tabindex="-1"><a class="header-anchor" href="#webpack-中自定义-loader" aria-hidden="true">#</a> webpack 中自定义 loader</h2><p>自定义 loader 是通过编写 Node.js 模块来实现的，这个模块需要导出一个函数。这个函数会在文件转换过程中被调用，并且接收文件内容作为参数。自定义 loader 的主要工作是将输入的文件内容进行转换，然后返回新的内容。</p><p>在 webpack 配置中，通过 module.rules 配置项来指定 loader</p><h2 id="babel-是什么" tabindex="-1"><a class="header-anchor" href="#babel-是什么" aria-hidden="true">#</a> babel 是什么？</h2>',20),u={href:"https://www.babeljs.cn/docs/",target:"_blank",rel:"noopener noreferrer"},b=a('<h2 id="写过的-webpack-插件、loader" tabindex="-1"><a class="header-anchor" href="#写过的-webpack-插件、loader" aria-hidden="true">#</a> 写过的 webpack 插件、loader？</h2><p>类似 eslint 插件，雪碧图 loader, 监控 loader</p><h2 id="rollup-常见配置、插件" tabindex="-1"><a class="header-anchor" href="#rollup-常见配置、插件" aria-hidden="true">#</a> rollup 常见配置、插件</h2><p>Rollup 是一个 JavaScript 模块打包器，它专注于将小块代码编译成更大、更复杂的代码块。下面是一些常见的 Rollup 配置和插件：</p><h3 id="常见配置" tabindex="-1"><a class="header-anchor" href="#常见配置" aria-hidden="true">#</a> 常见配置</h3><ul><li><code>input</code>：指定入口文件的路径。</li><li><code>output</code>：指定输出文件的配置，包括文件路径、格式等。</li><li><code>plugins</code>：配置使用的插件，例如处理 CSS、压缩代码等。</li></ul><h3 id="常见插件" tabindex="-1"><a class="header-anchor" href="#常见插件" aria-hidden="true">#</a> 常见插件</h3><ul><li><code>rollup-plugin-babel</code>：用于将 ES6+ 代码转换为兼容的 JavaScript 代码。</li><li><code>rollup-plugin-commonjs</code>：将 CommonJS 模块转换为 ES6 模块。</li><li><code>rollup-plugin-node-resolve</code>：解析第三方模块的路径。</li><li><code>rollup-plugin-terser</code>：压缩 JavaScript 代码。</li><li><code>rollup-plugin-postcss</code>：处理 CSS 文件。</li><li><code>rollup-plugin-sass</code>：处理 Sass 文件。</li><li><code>rollup-plugin-json</code>：处理 JSON 文件。</li></ul><p>这些是一些常见的 Rollup 配置和插件。</p>',9);function k(w,f){const l=d("ExternalLinkIcon");return p(),i("div",null,[t,e("blockquote",null,[e("p",null,[e("a",h,[r("配置 | webpack 中文文档"),o(l)])])]),s,e("blockquote",null,[e("p",null,[e("a",u,[r("Babel 是什么？ · Babel 中文文档 | Babel 中文网"),o(l)])])]),b])}const m=c(n,[["render",k],["__file","f1-buildTools.html.vue"]]);export{m as default};
